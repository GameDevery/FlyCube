#pragma once

#include <Program/Program.h>
#include <glm/glm.hpp>
#include <array>
#include <vector>
 
class {{ShaderName}} : public Shader<{{ShaderType}}>
{
public:
    struct
    { 
        {{#CBuffers}}
        struct
        {
            {{#Variables}}{{Type}} {{Name}};
            {{/Variables}}
        } {{BufferName}};
        {{/CBuffers}}
    } cbuffer;

    struct
    {
        {{#Textures}}static constexpr const UINT {{Name}} = {{Slot}};
        {{/Textures}}
    } texture;

    {{ShaderName}}(ComPtr<ID3D11Device>& device)
        : Shader(device, "{{ShaderPath}}", "{{Entrypoint}}", "{{Target}}")
        , cbuffer{}  
        , cbuffer_impl(device)     
    {
    }

    virtual void UpdateCBuffers(ComPtr<ID3D11DeviceContext>& device_context) override
    {
        {{#CBuffers}}cbuffer_impl.{{BufferName}}.UpdateCBuffer(device_context, (const char*)&cbuffer.{{BufferName}}); 
        {{/CBuffers}}
    } 
 
private:
    virtual void BindCBuffers(ComPtr<ID3D11DeviceContext>& device_context) override
    {
        {{#CBuffers}}cbuffer_impl.{{BufferName}}.BindCBuffer<{{ShaderType}}>(device_context);
        {{/CBuffers}}
    }
    
    class CBufferImpl
    {
    public:
        {{#CBuffers}}BufferLayout {{BufferName}};
        {{/CBuffers}}
        CBufferImpl(ComPtr<ID3D11Device>& device)
            : TODO(true)
            {{#CBuffers}}, {{BufferName}}(
                device,
                {{BufferSize}},
                {{BufferIndex}},
                {
                    {{#Variables}}{{VariableSize}}, {{/Variables}}
                },
                {
                    {{#Variables}}offsetof(decltype(cbuffer.{{BufferName}}), {{Name}}), {{/Variables}}              
                },
                {
                    {{#Variables}}{{StartOffset}}, {{/Variables}}
                }
            )
            {{/CBuffers}}
        {
        }

    private:
        bool TODO;

    } cbuffer_impl;
};
