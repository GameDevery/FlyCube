#pragma once

#include <Program/Program.h>
#include <glm/glm.hpp>
#include <array>
#include <vector>

class {{ShaderName}} : public Shader<{{ShaderType}}>
{
public:
    struct
    {
{{#CBuffers}}        struct
        {
{{#Variables}}            {{&Type}} {{Name}};
{{/Variables}}        } {{BufferName}};
{{/CBuffers}}    } cbuffer;

    struct SRV
    {
        SRV(ShaderBase& shader)
{{#Textures}}            {{Separator}} {{Name}}(shader, "{{Name}}", {{Slot}})
{{/Textures}}        {
        }

{{#Textures}}       SRVBinding {{Name}};
{{/Textures}}    } srv;

    struct UAV
    {
        UAV(ShaderBase& shader)
{{#UAVs}}            {{Separator}} {{Name}}(shader, "{{Name}}", {{Slot}})
{{/UAVs}}        {
        }

{{#UAVs}}       UAVBinding {{Name}};
{{/UAVs}}    } uav;

    struct
    {
{{#Inputs}}        static constexpr const uint32_t {{Name}} = {{Slot}};
{{/Inputs}}    } ia;

    {{#HasOutputs}}
    struct RTV
    {
        RTV(Context& context)
{{#Outputs}}            {{Separator}} rtv{{Slot}}(context, {{Slot}})
{{/Outputs}}            {{DSVSeparator}} dsv(context)
        {
        }

        void Apply(Context& context)
        {
            std::vector<ID3D11RenderTargetView*> rtv_ptr;
{{#Outputs}}            rtv_ptr.push_back(rtv{{Slot}}.GetRtv().Get());
{{/Outputs}}
            context.device_context->OMSetRenderTargets(rtv_ptr.size(), rtv_ptr.data(), dsv.GetDsv().Get());
        }

{{#Outputs}}        RTVBinding rtv{{Slot}};
{{/Outputs}}        DSVBinding dsv;
    } om;
    {{/HasOutputs}}

    struct
    {
{{#Samplers}}        static constexpr const uint32_t {{Name}} = {{Slot}};
{{/Samplers}}    } sampler;

    {{ShaderName}}(Context& context)
        : Shader(context, "{{ShaderPath}}", "{{Entrypoint}}", "{{Target}}")
        , cbuffer{}
        , srv(*this) 
        , uav(*this) 
        {{#HasOutputs}} , om(context) {{/HasOutputs}}
        , cbuffer_impl(context)
    {
    }

    virtual void UpdateCBuffers() override
    {
        {{#CBuffers}}cbuffer_impl.{{BufferName}}.UpdateCBuffer((const char*)&cbuffer.{{BufferName}}); 
        {{/CBuffers}}
    } 
 
private:
    virtual void BindCBuffers() override
    {
        {{#CBuffers}}cbuffer_impl.{{BufferName}}.BindCBuffer<{{ShaderType}}>();
        {{/CBuffers}}
    }
    
    class CBufferImpl
    {
    public:
        {{#CBuffers}}BufferLayout {{BufferName}};
        {{/CBuffers}}
        CBufferImpl(Context& context)
            {{#CBuffers}}{{BufferSeparator}} {{BufferName}}(
                context,
                "<{{BufferName}}>",
                {{BufferSize}},
                {{BufferIndex}},
                {
                    {{#Variables}}{{VariableSize}}, {{/Variables}}
                },
                {
                    {{#Variables}}offsetof(decltype(cbuffer.{{BufferName}}), {{Name}}), {{/Variables}}              
                },
                {
                    {{#Variables}}{{StartOffset}}, {{/Variables}}
                }
            )
            {{/CBuffers}}
        {
        }
    } cbuffer_impl;
};
