#pragma once

#include <Program/Program.h>
#include <glm/glm.hpp>
#include <array>
#include <vector>
#include <memory>

class {{ShaderName}} : public ShaderBase
{
    ProgramApi& program_api;

public:

    static const ShaderType type = {{ShaderType}};

    struct
    {
{{#CBuffers}}        struct
        {
{{#Variables}}            {{&Type}} {{Name}};
{{/Variables}}        } {{BufferName}};
{{/CBuffers}}    } cbuffer;

    struct SRV
    {
        SRV(ProgramApi& program_api)
{{#Textures}}            {{Separator}} {{Name}}(program_api, type, "{{Name}}", {{Slot}})
{{/Textures}}        {
        }

{{#Textures}}       SRVBinding {{Name}};
{{/Textures}}    } srv;

    struct UAV
    {
        UAV(ProgramApi& program_api)
{{#UAVs}}            {{Separator}} {{Name}}(program_api, type, "{{Name}}", {{Slot}})
{{/UAVs}}        {
        }

{{#UAVs}}       UAVBinding {{Name}};
{{/UAVs}}    } uav;

    struct IA
    {
{{#Inputs}}        static constexpr const uint32_t {{Name}} = {{Slot}};
{{/Inputs}}    } ia;

    {{#HasOutputs}}
    struct OM
    {
        OM(ProgramApi& program_api)
{{#Outputs}}            {{Separator}} rtv{{Slot}}(program_api, {{Slot}})
{{/Outputs}}            {{DSVSeparator}} dsv(program_api)
        {
        }

{{#Outputs}}        RTVBinding rtv{{Slot}};
{{/Outputs}}        DSVBinding dsv;
    } om;
    {{/HasOutputs}}

    struct Sampler
    {
        Sampler(ProgramApi& program_api)
{{#Samplers}}            {{Separator}} {{Name}}(program_api, type, "{{Name}}", {{Slot}})
{{/Samplers}}        {
        }

{{#Samplers}}       SamplerBinding {{Name}};
{{/Samplers}}    } sampler;

    {{ShaderName}}(ProgramApi& program_api)
        : ShaderBase(type, "{{ShaderPath}}", "{{Entrypoint}}", "{{Target}}")
        , program_api(program_api)
        , cbuffer{}
        , srv(program_api)
        , uav(program_api)
        {{#HasOutputs}}, om(program_api) {{/HasOutputs}}
        , sampler(program_api)
        , cbuffer_impl(*this)
    {
        program_api.AddAvailableShaderType(type);      
        {{#CBuffers}}
        {
            BindKey bind_key = { program_api.GetProgramId(), type, ResourceType::kCbv, {{BufferIndex}} };
            program_api.SetCBufferLayout(bind_key, cbuffer_impl.{{BufferName}});
            program_api.SetBindingName(bind_key, "{{BufferName}}");
        }
        {{/CBuffers}}
    }

    virtual void UpdateShader() override
    {
        program_api.CompileShader(*this);
    }

private:
    class CBufferImpl
    {
    public:
        {{#CBuffers}}BufferLayout {{BufferName}};
        {{/CBuffers}}
        CBufferImpl({{ShaderName}}& shader)
            {{#CBuffers}}{{BufferSeparator}} {{BufferName}}(
                (const char*)&shader.cbuffer.{{BufferName}},
                {{BufferSize}},
                {
                    {{#Variables}}{{VariableSize}}, {{/Variables}}
                },
                {
                    {{#Variables}}offsetof(decltype(cbuffer.{{BufferName}}), {{Name}}), {{/Variables}}              
                },
                {
                    {{#Variables}}{{StartOffset}}, {{/Variables}}
                }
            )
            {{/CBuffers}}
        {
        }
    } cbuffer_impl;
};
