#pragma once

#include <Program/Program.h>
#include <glm/glm.hpp>
#include <array>
#include <vector>
#include <memory>

class {{ShaderName}} : public ShaderBase
{
    std::unique_ptr<ShaderApi> shader_api;

public:

    static const ShaderType type = {{ShaderType}};

    struct
    {
{{#CBuffers}}        struct
        {
{{#Variables}}            {{&Type}} {{Name}};
{{/Variables}}        } {{BufferName}};
{{/CBuffers}}    } cbuffer;

    struct SRV
    {
        SRV(ShaderApi& shader)
{{#Textures}}            {{Separator}} {{Name}}(shader, "{{Name}}", {{Slot}})
{{/Textures}}        {
        }

{{#Textures}}       SRVBinding {{Name}};
{{/Textures}}    } srv;

    struct UAV
    {
        UAV(ShaderApi& shader)
{{#UAVs}}            {{Separator}} {{Name}}(shader, "{{Name}}", {{Slot}})
{{/UAVs}}        {
        }

{{#UAVs}}       UAVBinding {{Name}};
{{/UAVs}}    } uav;

    struct
    {
{{#Inputs}}        static constexpr const uint32_t {{Name}} = {{Slot}};
{{/Inputs}}    } ia;

    struct
    {
{{#Outputs}}        static constexpr const uint32_t {{Name}} = {{Slot}};
{{/Outputs}}    } om;

    struct Sampler
    {
        Sampler(ShaderApi& shader)
{{#Samplers}}            {{Separator}} {{Name}}(shader, {{Slot}})
{{/Samplers}}        {
        }

{{#Samplers}}       SamplerBinding {{Name}};
{{/Samplers}}    } sampler;

    {{ShaderName}}(ProgramApi& program_base)
        : ShaderBase("{{ShaderPath}}", "{{Entrypoint}}", "{{Target}}")
        , shader_api(program_base.CreateShader({{ShaderType}}))
        , cbuffer{}
        , srv(*shader_api)
        , uav(*shader_api)
        , sampler(*shader_api)
        , cbuffer_impl(*shader_api)
    {
    }

    virtual void UpdateShader() override
    {
        m_shader_buffer = CompileShader();
        shader_api->CreateShader(m_shader_buffer);
    }

    virtual void UseShader() override
    {
        shader_api->UseShader();
    }

    virtual void UpdateCBuffers() override
    {
        {{#CBuffers}}cbuffer_impl.{{BufferName}}.UpdateCBuffer((const char*)&cbuffer.{{BufferName}}); 
        {{/CBuffers}}
    } 
 
private:
    virtual void BindCBuffers() override
    {
        {{#CBuffers}}shader_api->BindCBuffer({{BufferIndex}}, cbuffer_impl.{{BufferName}}.GetBuffer());
        {{/CBuffers}}
    }
    
    class CBufferImpl
    {
    public:
        {{#CBuffers}}BufferLayout {{BufferName}};
        {{/CBuffers}}
        CBufferImpl(ShaderApi& shader)
            {{#CBuffers}}{{BufferSeparator}} {{BufferName}}(
                shader,
                "<{{BufferName}}>",
                {{BufferSize}},
                {{BufferIndex}},
                {
                    {{#Variables}}{{VariableSize}}, {{/Variables}}
                },
                {
                    {{#Variables}}offsetof(decltype(cbuffer.{{BufferName}}), {{Name}}), {{/Variables}}              
                },
                {
                    {{#Variables}}{{StartOffset}}, {{/Variables}}
                }
            )
            {{/CBuffers}}
        {
        }
    } cbuffer_impl;
};
